#!/usr/bin/env -S npx tsx

/**
 * Release Script
 * Creates a release based on the version in package.json
 *
 * Usage:
 *   1. Update version in package.json manually
 *   2. Commit the version bump
 *   3. pnpm release         # Create release (pushes & creates GitHub release)
 *   4. pnpm release --dry-run # Test without making changes
 */

import { execSync } from "child_process"
import { readFile, writeFile } from "fs/promises"
import { join } from "path"

interface PackageJson {
  name: string
  version: string
  [key: string]: unknown
}

const ROOT_DIR = join(import.meta.dirname, "..")
const PACKAGE_JSON_PATH = join(ROOT_DIR, "package.json")

/**
 * Execute shell command and return output
 */
function exec(command: string, silent = false): string {
  try {
    return execSync(command, {
      cwd: ROOT_DIR,
      encoding: "utf-8",
      stdio: silent ? "pipe" : "inherit"
    })
  } catch (error) {
    throw new Error(`Command failed: ${command}\n${error}`)
  }
}

/**
 * Check if git working directory is clean
 */
function checkGitStatus(): void {
  const status = exec("git status --porcelain", true).trim()
  if (status) {
    console.error("Git working directory is not clean:")
    console.error(status)
    console.error("\nPlease commit or stash your changes before releasing.")
    process.exit(1)
  }
}

/**
 * Check if on main branch
 */
function checkGitBranch(): void {
  const branch = exec("git rev-parse --abbrev-ref HEAD", true).trim()
  if (branch !== "main") {
    console.error(`Not on main branch (currently on: ${branch})`)
    console.error("Please switch to main branch before releasing.")
    process.exit(1)
  }
}

/**
 * Check if git tag already exists
 */
function tagExists(version: string): boolean {
  try {
    exec(`git rev-parse v${version}`, true)
    return true
  } catch {
    return false
  }
}

/**
 * Create version constant file for runtime access
 */
async function createVersionFile(version: string): Promise<void> {
  const versionFilePath = join(ROOT_DIR, "src", "version.ts")
  const content = `/**
 * Package version - auto-generated by release script
 * @packageDocumentation
 */

export const VERSION = "${version}"
`

  await writeFile(versionFilePath, content, "utf-8")
}

/**
 * Main release process
 */
async function release(dryRun = false): Promise<void> {
  console.log(`\nStarting ${dryRun ? "DRY RUN " : ""}release process...\n`)

  // Read current version from package.json
  const pkgContent = await readFile(PACKAGE_JSON_PATH, "utf-8")
  const pkg: PackageJson = JSON.parse(pkgContent)
  const version = pkg.version

  console.log(`Package: ${pkg.name}`)
  console.log(`Version: ${version}`)
  console.log()

  if (!dryRun) {
    // Check if tag already exists
    if (tagExists(version)) {
      console.error(`Git tag v${version} already exists!`)
      console.error("Please update the version in package.json to a new version.")
      process.exit(1)
    }

    // Pre-release checks
    console.log("Running pre-release checks...")
    checkGitStatus()
    checkGitBranch()
    console.log("Git checks passed\n")

    // Lint and type check
    console.log("Running lint and type check...")
    exec("pnpm run lint")
    exec("pnpm run build")
    console.log("Lint and type check passed\n")

    // Update version file
    console.log("Updating version file...")
    await createVersionFile(version)
    console.log("Version file updated\n")

    // Git commit and tag
    console.log("Creating git commit and tag...")
    exec("git add src/version.ts")
    exec(`git commit -m "chore: release v${version}"`)
    exec(`git tag -a v${version} -m "Release v${version}"`)
    console.log("Git commit and tag created\n")

    // Push to remote
    console.log("Pushing to remote...")
    exec("git push")
    exec("git push --tags")
    console.log("Pushed to remote\n")

    // Create GitHub release
    console.log("Creating GitHub release...")
    exec(`gh release create v${version} --title "v${version}" --generate-notes`)
    console.log("GitHub release created\n")

    console.log("Release complete!\n")
    console.log("Optional next steps:")
    console.log("  - Publish to npm: pnpm publish")
    console.log("  - Publish to private registry: pnpm publish --registry <url>")
  } else {
    console.log("DRY RUN - No changes will be made")
    console.log("\nWould perform:")
    console.log("  - Run lint (pnpm lint)")
    console.log("  - Run type check (pnpm build)")
    console.log(`  - Create src/version.ts with version ${version}`)
    console.log(`  - Git commit and tag: v${version}`)
    console.log("  - Push commits and tags to remote")
    console.log(`  - Create GitHub release v${version}`)
  }

  console.log()
}

/**
 * CLI entry point
 */
async function main(): Promise<void> {
  const args = process.argv.slice(2)

  if (args.includes("--help") || args.includes("-h")) {
    console.log(`
Usage: pnpm release [--dry-run]

Creates a release based on the version specified in package.json

Steps:
  1. Update version in package.json manually (e.g., "0.9.0" -> "1.0.0")
  2. Commit the version bump
  3. Run: pnpm release

The script will:
  - Run lint (pnpm lint)
  - Run type check (pnpm build)
  - Create src/version.ts with the version
  - Create git commit and tag
  - Push to remote
  - Create GitHub release (requires gh CLI)

Options:
  --dry-run    Test release process without making changes

Examples:
  pnpm release              # Create release
  pnpm release --dry-run    # Test without changes
`)
    process.exit(0)
  }

  const isDryRun = args.includes("--dry-run")

  try {
    await release(isDryRun)
  } catch (error) {
    console.error("\nRelease failed:")
    console.error(error instanceof Error ? error.message : String(error))
    process.exit(1)
  }
}

main()
